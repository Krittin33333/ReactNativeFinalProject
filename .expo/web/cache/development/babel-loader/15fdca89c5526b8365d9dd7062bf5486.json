{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nimport * as React from 'react';\nimport Platform from \"react-native-web/dist/exports/Platform\";\nimport StyleSheet from \"react-native-web/dist/exports/StyleSheet\";\nimport Animated from \"react-native-web/dist/exports/Animated\";\nimport BackHandler from \"react-native-web/dist/exports/BackHandler\";\nimport Dimensions from \"react-native-web/dist/exports/Dimensions\";\nimport Easing from \"react-native-web/dist/exports/Easing\";\nimport I18nManager from \"react-native-web/dist/exports/I18nManager\";\nimport TouchableWithoutFeedback from \"react-native-web/dist/exports/TouchableWithoutFeedback\";\nimport View from \"react-native-web/dist/exports/View\";\nimport ScrollView from \"react-native-web/dist/exports/ScrollView\";\nimport findNodeHandle from \"react-native-web/dist/exports/findNodeHandle\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { jsxs as _jsxs } from \"react/jsx-runtime\";\nvar APPROX_STATUSBAR_HEIGHT = 25;\nvar SCREEN_INDENT = 8;\nvar ANIMATION_DURATION = 250;\nvar EASING = Easing.bezier(0.4, 0, 0.2, 1);\nexport var Menu = function (_React$Component) {\n  _inherits(Menu, _React$Component);\n\n  var _super = _createSuper(Menu);\n\n  function Menu() {\n    var _this;\n\n    _classCallCheck(this, Menu);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _super.call.apply(_super, [this].concat(args));\n    _this.state = {\n      rendered: _this.props.visible,\n      top: 0,\n      left: 0,\n      menuLayout: {\n        width: 0,\n        height: 0\n      },\n      anchorLayout: {\n        width: 0,\n        height: 0\n      },\n      opacityAnimation: new Animated.Value(0),\n      scaleAnimation: new Animated.ValueXY({\n        x: 0,\n        y: 0\n      })\n    };\n    _this.anchor = null;\n    _this.menu = null;\n\n    _this.isAnchorCoord = function () {\n      return !React.isValidElement(_this.props.anchor);\n    };\n\n    _this.measureMenuLayout = function () {\n      return new Promise(function (resolve) {\n        if (_this.menu) {\n          _this.menu.measureInWindow(function (x, y, width, height) {\n            resolve({\n              x: x,\n              y: y,\n              width: width,\n              height: height\n            });\n          });\n        }\n      });\n    };\n\n    _this.measureAnchorLayout = function () {\n      return new Promise(function (resolve) {\n        var anchor = _this.props.anchor;\n\n        if (_this.isAnchorCoord()) {\n          resolve({\n            x: anchor.x,\n            y: anchor.y,\n            width: 0,\n            height: 0\n          });\n          return;\n        }\n\n        if (_this.anchor) {\n          _this.anchor.measureInWindow(function (x, y, width, height) {\n            resolve({\n              x: x,\n              y: y,\n              width: width,\n              height: height\n            });\n          });\n        }\n      });\n    };\n\n    _this.updateVisibility = function _callee() {\n      return _regeneratorRuntime.async(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _context.next = 2;\n              return _regeneratorRuntime.awrap(Promise.resolve());\n\n            case 2:\n              if (_this.props.visible) {\n                _this.show();\n              } else {\n                _this.hide();\n              }\n\n            case 3:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, null, null, null, Promise);\n    };\n\n    _this.isBrowser = function () {\n      return Platform.OS === 'web' && 'document' in global;\n    };\n\n    _this.focusFirstDOMNode = function (el) {\n      if (el && _this.isBrowser()) {\n        var node = findNodeHandle(el);\n        var focusableNode = node.querySelector('button, [href], input, select, textarea, [tabindex]:not([tabindex=\"-1\"])');\n        focusableNode == null ? void 0 : focusableNode.focus();\n      }\n    };\n\n    _this.handleDismiss = function () {\n      if (_this.props.visible) {\n        _this.props.onDismiss();\n      }\n\n      return true;\n    };\n\n    _this.handleKeypress = function (e) {\n      if (e.key === 'Escape') {\n        _this.props.onDismiss();\n      }\n    };\n\n    _this.attachListeners = function () {\n      BackHandler.addEventListener('hardwareBackPress', _this.handleDismiss);\n      Dimensions.addEventListener('change', _this.handleDismiss);\n      _this.isBrowser() && document.addEventListener('keyup', _this.handleKeypress);\n    };\n\n    _this.removeListeners = function () {\n      BackHandler.removeEventListener('hardwareBackPress', _this.handleDismiss);\n      Dimensions.removeEventListener('change', _this.handleDismiss);\n      _this.isBrowser() && document.removeEventListener('keyup', _this.handleKeypress);\n    };\n\n    _this.show = function _callee2() {\n      var windowLayout, _await$Promise$all, _await$Promise$all2, menuLayout, anchorLayout;\n\n      return _regeneratorRuntime.async(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              windowLayout = Dimensions.get('window');\n              _context2.next = 3;\n              return _regeneratorRuntime.awrap(Promise.all([_this.measureMenuLayout(), _this.measureAnchorLayout()]));\n\n            case 3:\n              _await$Promise$all = _context2.sent;\n              _await$Promise$all2 = _slicedToArray(_await$Promise$all, 2);\n              menuLayout = _await$Promise$all2[0];\n              anchorLayout = _await$Promise$all2[1];\n\n              if (!(!windowLayout.width || !windowLayout.height || !menuLayout.width || !menuLayout.height || !anchorLayout.width && !_this.isAnchorCoord() || !anchorLayout.height && !_this.isAnchorCoord())) {\n                _context2.next = 10;\n                break;\n              }\n\n              requestAnimationFrame(_this.show);\n              return _context2.abrupt(\"return\");\n\n            case 10:\n              _this.setState(function () {\n                return {\n                  left: anchorLayout.x,\n                  top: anchorLayout.y,\n                  anchorLayout: {\n                    height: anchorLayout.height,\n                    width: anchorLayout.width\n                  },\n                  menuLayout: {\n                    width: menuLayout.width,\n                    height: menuLayout.height\n                  }\n                };\n              }, function () {\n                _this.attachListeners();\n\n                var _animation = {\n                  animation: {\n                    scale: 1.0\n                  }\n                },\n                    animation = _animation.animation;\n                Animated.parallel([Animated.timing(_this.state.scaleAnimation, {\n                  toValue: {\n                    x: menuLayout.width,\n                    y: menuLayout.height\n                  },\n                  duration: ANIMATION_DURATION * animation.scale,\n                  easing: EASING,\n                  useNativeDriver: true\n                }), Animated.timing(_this.state.opacityAnimation, {\n                  toValue: 1,\n                  duration: ANIMATION_DURATION * animation.scale,\n                  easing: EASING,\n                  useNativeDriver: true\n                })]).start(function (_ref) {\n                  var finished = _ref.finished;\n\n                  if (finished) {\n                    _this.focusFirstDOMNode(_this.menu);\n                  }\n                });\n              });\n\n            case 11:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, null, null, null, Promise);\n    };\n\n    _this.hide = function () {\n      _this.removeListeners();\n\n      var _animation2 = {\n        animation: {\n          scale: 1.0\n        }\n      },\n          animation = _animation2.animation;\n      Animated.timing(_this.state.opacityAnimation, {\n        toValue: 0,\n        duration: ANIMATION_DURATION * animation.scale,\n        easing: EASING,\n        useNativeDriver: true\n      }).start(function (_ref2) {\n        var finished = _ref2.finished;\n\n        if (finished) {\n          _this.setState({\n            menuLayout: {\n              width: 0,\n              height: 0\n            },\n            rendered: false\n          });\n\n          _this.state.scaleAnimation.setValue({\n            x: 0,\n            y: 0\n          });\n\n          _this.focusFirstDOMNode(_this.anchor);\n        }\n      });\n    };\n\n    return _this;\n  }\n\n  _createClass(Menu, [{\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps) {\n      if (prevProps.visible !== this.props.visible) {\n        this.updateVisibility();\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this.removeListeners();\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this2 = this;\n\n      var _this$props = this.props,\n          visible = _this$props.visible,\n          contentStyle = _this$props.contentStyle,\n          style = _this$props.style,\n          children = _this$props.children,\n          statusBarHeight = _this$props.statusBarHeight,\n          onDismiss = _this$props.onDismiss,\n          overlayAccessibilityLabel = _this$props.overlayAccessibilityLabel;\n      var _this$state = this.state,\n          rendered = _this$state.rendered,\n          menuLayout = _this$state.menuLayout,\n          anchorLayout = _this$state.anchorLayout,\n          opacityAnimation = _this$state.opacityAnimation,\n          scaleAnimation = _this$state.scaleAnimation;\n      var _this$state2 = this.state,\n          left = _this$state2.left,\n          top = _this$state2.top;\n      var additionalVerticalValue = Platform.select({\n        android: statusBarHeight,\n        default: 0\n      });\n      var scaleTransforms = [{\n        scaleX: scaleAnimation.x.interpolate({\n          inputRange: [0, menuLayout.width],\n          outputRange: [0, 1]\n        })\n      }, {\n        scaleY: scaleAnimation.y.interpolate({\n          inputRange: [0, menuLayout.height],\n          outputRange: [0, 1]\n        })\n      }];\n      var windowLayout = Dimensions.get('window');\n      var positionTransforms = [];\n\n      if (left <= windowLayout.width - menuLayout.width - SCREEN_INDENT) {\n        positionTransforms.push({\n          translateX: scaleAnimation.x.interpolate({\n            inputRange: [0, menuLayout.width],\n            outputRange: [-(menuLayout.width / 2), 0]\n          })\n        });\n\n        if (left < SCREEN_INDENT) {\n          left = SCREEN_INDENT;\n        }\n      } else {\n        positionTransforms.push({\n          translateX: scaleAnimation.x.interpolate({\n            inputRange: [0, menuLayout.width],\n            outputRange: [menuLayout.width / 2, 0]\n          })\n        });\n        left += anchorLayout.width - menuLayout.width;\n        var right = left + menuLayout.width;\n\n        if (right > windowLayout.width - SCREEN_INDENT) {\n          left = windowLayout.width - SCREEN_INDENT - menuLayout.width;\n        }\n      }\n\n      var scrollableMenuHeight = 0;\n\n      if (top >= windowLayout.height - menuLayout.height - SCREEN_INDENT - additionalVerticalValue && top <= windowLayout.height - top) {\n        scrollableMenuHeight = windowLayout.height - top - SCREEN_INDENT - additionalVerticalValue;\n      } else if (top >= windowLayout.height - menuLayout.height - SCREEN_INDENT - additionalVerticalValue && top >= windowLayout.height - top && top <= menuLayout.height - anchorLayout.height + SCREEN_INDENT - additionalVerticalValue) {\n        scrollableMenuHeight = top + anchorLayout.height - SCREEN_INDENT + additionalVerticalValue;\n      }\n\n      scrollableMenuHeight = scrollableMenuHeight > windowLayout.height - 2 * SCREEN_INDENT ? windowLayout.height - 2 * SCREEN_INDENT : scrollableMenuHeight;\n\n      if (top <= windowLayout.height - menuLayout.height - SCREEN_INDENT - additionalVerticalValue || top >= windowLayout.height - menuLayout.height - SCREEN_INDENT - additionalVerticalValue && top <= windowLayout.height - top) {\n        positionTransforms.push({\n          translateY: scaleAnimation.y.interpolate({\n            inputRange: [0, menuLayout.height],\n            outputRange: [-((scrollableMenuHeight || menuLayout.height) / 2), 0]\n          })\n        });\n\n        if (top < SCREEN_INDENT) {\n          top = SCREEN_INDENT;\n        }\n      } else {\n        positionTransforms.push({\n          translateY: scaleAnimation.y.interpolate({\n            inputRange: [0, menuLayout.height],\n            outputRange: [(scrollableMenuHeight || menuLayout.height) / 2, 0]\n          })\n        });\n        top += anchorLayout.height - (scrollableMenuHeight || menuLayout.height);\n        var bottom = top + (scrollableMenuHeight || menuLayout.height) + additionalVerticalValue;\n\n        if (bottom > windowLayout.height - SCREEN_INDENT) {\n          top = scrollableMenuHeight === windowLayout.height - 2 * SCREEN_INDENT ? -SCREEN_INDENT * 2 : windowLayout.height - menuLayout.height - SCREEN_INDENT - additionalVerticalValue;\n        }\n      }\n\n      var shadowMenuContainerStyle = _objectSpread({\n        opacity: opacityAnimation,\n        transform: scaleTransforms,\n        borderRadius: 5\n      }, scrollableMenuHeight ? {\n        height: scrollableMenuHeight\n      } : {});\n\n      var positionStyle = _objectSpread({\n        top: this.isAnchorCoord() ? top : top + additionalVerticalValue\n      }, I18nManager.isRTL ? {\n        right: left\n      } : {\n        left: left\n      });\n\n      return rendered ? _jsxs(View, {\n        style: StyleSheet.absoluteFill,\n        collapsable: false,\n        children: [_jsx(TouchableWithoutFeedback, {\n          accessibilityLabel: overlayAccessibilityLabel,\n          accessibilityRole: \"button\",\n          onPress: onDismiss,\n          children: _jsx(View, {\n            style: StyleSheet.absoluteFill\n          })\n        }), _jsx(View, {\n          ref: function ref(_ref3) {\n            _this2.menu = _ref3;\n          },\n          collapsable: false,\n          accessibilityViewIsModal: visible,\n          style: [styles.wrapper, positionStyle, style],\n          pointerEvents: visible ? 'box-none' : 'none',\n          onAccessibilityEscape: onDismiss,\n          children: _jsx(Animated.View, {\n            style: {\n              transform: positionTransforms\n            },\n            children: _jsx(Animated.View, {\n              style: [styles.shadowMenuContainer, styles.surface, shadowMenuContainerStyle, contentStyle],\n              children: scrollableMenuHeight && _jsx(ScrollView, {\n                children: children\n              }) || _jsx(React.Fragment, {\n                children: children\n              })\n            })\n          })\n        })]\n      }) : null;\n    }\n  }], [{\n    key: \"getDerivedStateFromProps\",\n    value: function getDerivedStateFromProps(nextProps, prevState) {\n      if (nextProps.visible && !prevState.rendered) {\n        return {\n          rendered: true\n        };\n      }\n\n      return null;\n    }\n  }]);\n\n  return Menu;\n}(React.Component);\nMenu.defaultProps = {\n  statusBarHeight: APPROX_STATUSBAR_HEIGHT,\n  overlayAccessibilityLabel: 'Close menu'\n};\nvar styles = StyleSheet.create({\n  wrapper: {\n    position: 'absolute'\n  },\n  shadowMenuContainer: _objectSpread({\n    opacity: 0,\n    paddingVertical: 8\n  }, Platform.select({\n    android: {\n      elevation: 8\n    },\n    default: {\n      shadowColor: 'black',\n      shadowOffset: {\n        width: 0,\n        height: 7\n      },\n      shadowOpacity: 0.24,\n      shadowRadius: 8\n    }\n  })),\n  surface: {\n    backgroundColor: 'white'\n  }\n});","map":{"version":3,"names":["React","APPROX_STATUSBAR_HEIGHT","SCREEN_INDENT","ANIMATION_DURATION","EASING","Easing","bezier","Menu","state","rendered","props","visible","top","left","menuLayout","width","height","anchorLayout","opacityAnimation","Animated","Value","scaleAnimation","ValueXY","x","y","anchor","menu","isAnchorCoord","isValidElement","measureMenuLayout","Promise","resolve","measureInWindow","measureAnchorLayout","updateVisibility","show","hide","isBrowser","Platform","OS","global","focusFirstDOMNode","el","node","findNodeHandle","focusableNode","querySelector","focus","handleDismiss","onDismiss","handleKeypress","e","key","attachListeners","BackHandler","addEventListener","Dimensions","document","removeListeners","removeEventListener","windowLayout","get","all","requestAnimationFrame","setState","animation","scale","parallel","timing","toValue","duration","easing","useNativeDriver","start","finished","setValue","prevProps","contentStyle","style","children","statusBarHeight","overlayAccessibilityLabel","additionalVerticalValue","select","android","default","scaleTransforms","scaleX","interpolate","inputRange","outputRange","scaleY","positionTransforms","push","translateX","right","scrollableMenuHeight","translateY","bottom","shadowMenuContainerStyle","opacity","transform","borderRadius","positionStyle","I18nManager","isRTL","StyleSheet","absoluteFill","ref","styles","wrapper","shadowMenuContainer","surface","nextProps","prevState","Component","defaultProps","create","position","paddingVertical","elevation","shadowColor","shadowOffset","shadowOpacity","shadowRadius","backgroundColor"],"sources":["E:/reactpro/ReactNativeFinalProject/node_modules/react-navigation-header-buttons/src/overflowMenu/vendor/Menu.js"],"sourcesContent":["// @flow\r\n// menu has a bunch of errors so typecheck is ignored but we want to keep flow syntax in here\r\n\r\nimport * as React from 'react';\r\nimport {\r\n  Platform,\r\n  StyleSheet,\r\n  Animated,\r\n  BackHandler,\r\n  Dimensions,\r\n  Easing,\r\n  I18nManager,\r\n  TouchableWithoutFeedback,\r\n  View,\r\n  ScrollView,\r\n  findNodeHandle,\r\n} from 'react-native';\r\n\r\nimport type { ViewStyleProp as ViewStyle } from 'react-native/Libraries/StyleSheet/StyleSheet';\r\ntype LayoutRectangle = { x: number, y: number, width: number, height: number };\r\n\r\n// NOTE this is ignored in our case bcs of this.isAnchorCoord() condition\r\nconst APPROX_STATUSBAR_HEIGHT = 25;\r\n\r\ntype Props = {\r\n  /**\r\n   * Whether the Menu is currently visible.\r\n   */\r\n  visible: boolean,\r\n  /**\r\n   * The anchor to open the menu from. In most cases, it will be a button that opens the menu.\r\n   */\r\n  anchor: React.Node | { x: number, y: number },\r\n  /**\r\n   * Extra margin to add at the top of the menu to account for translucent status bar on Android.\r\n   * If you are using Expo, we assume translucent status bar and set a height for status bar automatically.\r\n   * Pass `0` or a custom value to and customize it.\r\n   * This is automatically handled on iOS.\r\n   */\r\n  statusBarHeight?: number,\r\n  /**\r\n   * Callback called when Menu is dismissed. The `visible` prop needs to be updated when this is called.\r\n   */\r\n  onDismiss: () => void,\r\n  /**\r\n   * Accessibility label for the overlay. This is read by the screen reader when the user taps outside the menu.\r\n   */\r\n  overlayAccessibilityLabel?: string,\r\n  /**\r\n   * Content of the `Menu`.\r\n   */\r\n  children: React.Node,\r\n  /**\r\n   * Style of menu's inner content.\r\n   */\r\n  contentStyle?: ViewStyle,\r\n  style?: ViewStyle,\r\n};\r\n\r\ntype Layout = { width: number, height: number };\r\n\r\ntype State = {\r\n  rendered: boolean,\r\n  top: number,\r\n  left: number,\r\n  menuLayout: Layout,\r\n  anchorLayout: Layout,\r\n  opacityAnimation: Animated.Value,\r\n  scaleAnimation: Animated.ValueXY,\r\n};\r\n\r\n// Minimum padding between the edge of the screen and the menu\r\nconst SCREEN_INDENT = 8;\r\n// From https://material.io/design/motion/speed.html#duration\r\nconst ANIMATION_DURATION = 250;\r\n// From the 'Standard easing' section of https://material.io/design/motion/speed.html#easing\r\nconst EASING = Easing.bezier(0.4, 0, 0.2, 1);\r\n\r\n/**\r\n * Menus display a list of choices on temporary elevated surfaces. Their placement varies based on the element that opens them.\r\n *\r\n *  <div class=\"screenshots\">\r\n *   <img class=\"medium\" src=\"screenshots/menu-1.png\" />\r\n *   <img class=\"medium\" src=\"screenshots/menu-2.png\" />\r\n * </div>\r\n *\r\n * ## Usage\r\n * ```js\r\n * import * as React from 'react';\r\n * import { View } from 'react-native';\r\n * import { Button, Paragraph, Menu, Divider, Provider } from 'react-native-paper';\r\n *\r\n * export default class MyComponent extends React.Component {\r\n *   state = {\r\n *     visible: false,\r\n *   };\r\n *\r\n *   _openMenu = () => this.setState({ visible: true });\r\n *\r\n *   _closeMenu = () => this.setState({ visible: false });\r\n *\r\n *   render() {\r\n *     return (\r\n *       <Provider>\r\n *         <View\r\n *           style={{\r\n *             paddingTop: 50,\r\n *             flexDirection: 'row',\r\n *             justifyContent: 'center'\r\n *           }}>\r\n *           <Menu\r\n *             visible={this.state.visible}\r\n *             onDismiss={this._closeMenu}\r\n *             anchor={\r\n *               <Button onPress={this._openMenu}>Show menu</Button>\r\n *             }\r\n *           >\r\n *             <Menu.Item onPress={() => {}} title=\"Item 1\" />\r\n *             <Menu.Item onPress={() => {}} title=\"Item 2\" />\r\n *             <Divider />\r\n *             <Menu.Item onPress={() => {}} title=\"Item 3\" />\r\n *           </Menu>\r\n *         </View>\r\n *       </Provider>\r\n *     );\r\n *   }\r\n * }\r\n * ```\r\n */\r\nexport class Menu extends React.Component<Props, State> {\r\n  // @component ./MenuItem.tsx\r\n  //   static Item = MenuItem;\r\n\r\n  static defaultProps = {\r\n    statusBarHeight: APPROX_STATUSBAR_HEIGHT,\r\n    overlayAccessibilityLabel: 'Close menu',\r\n  };\r\n\r\n  static getDerivedStateFromProps(nextProps: Props, prevState: State) {\r\n    if (nextProps.visible && !prevState.rendered) {\r\n      return { rendered: true };\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  state = {\r\n    rendered: this.props.visible,\r\n    top: 0,\r\n    left: 0,\r\n    menuLayout: { width: 0, height: 0 },\r\n    anchorLayout: { width: 0, height: 0 },\r\n    opacityAnimation: new Animated.Value(0),\r\n    scaleAnimation: new Animated.ValueXY({ x: 0, y: 0 }),\r\n  };\r\n\r\n  componentDidUpdate(prevProps: Props) {\r\n    if (prevProps.visible !== this.props.visible) {\r\n      this.updateVisibility();\r\n    }\r\n  }\r\n\r\n  componentWillUnmount() {\r\n    this.removeListeners();\r\n  }\r\n\r\n  anchor: typeof View | null = null;\r\n  menu: typeof View | null = null;\r\n\r\n  isAnchorCoord = () => !React.isValidElement(this.props.anchor);\r\n\r\n  measureMenuLayout = () =>\r\n    new Promise<LayoutRectangle>((resolve) => {\r\n      if (this.menu) {\r\n        // $FlowFixMe\r\n        this.menu.measureInWindow((x, y, width, height) => {\r\n          resolve({ x, y, width, height });\r\n        });\r\n      }\r\n    });\r\n\r\n  measureAnchorLayout = () =>\r\n    new Promise<LayoutRectangle>((resolve) => {\r\n      const { anchor } = this.props;\r\n      if (this.isAnchorCoord()) {\r\n        // $FlowFixMe\r\n        resolve({ x: anchor.x, y: anchor.y, width: 0, height: 0 });\r\n        return;\r\n      }\r\n\r\n      if (this.anchor) {\r\n        // $FlowFixMe\r\n        this.anchor.measureInWindow((x, y, width, height) => {\r\n          resolve({ x, y, width, height });\r\n        });\r\n      }\r\n    });\r\n\r\n  updateVisibility = async () => {\r\n    // Menu is rendered in Portal, which updates items asynchronously\r\n    // We need to do the same here so that the ref is up-to-date\r\n    await Promise.resolve();\r\n\r\n    if (this.props.visible) {\r\n      this.show();\r\n    } else {\r\n      this.hide();\r\n    }\r\n  };\r\n\r\n  isBrowser = () => Platform.OS === 'web' && 'document' in global;\r\n\r\n  focusFirstDOMNode = (el: typeof View | null | typeof undefined) => {\r\n    if (el && this.isBrowser()) {\r\n      // When in the browser, we want to focus the first focusable item on toggle\r\n      // For example, when menu is shown, focus the first item in the menu\r\n      // And when menu is dismissed, send focus back to the button to resume tabbing\r\n      const node: any = findNodeHandle(el);\r\n      const focusableNode = node.querySelector(\r\n        // This is a rough list of selectors that can be focused\r\n        'button, [href], input, select, textarea, [tabindex]:not([tabindex=\"-1\"])'\r\n      );\r\n\r\n      // $FlowFixMe\r\n      focusableNode?.focus();\r\n    }\r\n  };\r\n\r\n  handleDismiss = () => {\r\n    if (this.props.visible) {\r\n      this.props.onDismiss();\r\n    }\r\n    return true;\r\n  };\r\n\r\n  handleKeypress = (e: KeyboardEvent) => {\r\n    if (e.key === 'Escape') {\r\n      this.props.onDismiss();\r\n    }\r\n  };\r\n\r\n  attachListeners = () => {\r\n    BackHandler.addEventListener('hardwareBackPress', this.handleDismiss);\r\n    Dimensions.addEventListener('change', this.handleDismiss);\r\n\r\n    this.isBrowser() && document.addEventListener('keyup', this.handleKeypress);\r\n  };\r\n\r\n  removeListeners = () => {\r\n    BackHandler.removeEventListener('hardwareBackPress', this.handleDismiss);\r\n    Dimensions.removeEventListener('change', this.handleDismiss);\r\n\r\n    this.isBrowser() && document.removeEventListener('keyup', this.handleKeypress);\r\n  };\r\n\r\n  show = async () => {\r\n    const windowLayout = Dimensions.get('window');\r\n    const [menuLayout, anchorLayout] = await Promise.all([\r\n      this.measureMenuLayout(),\r\n      this.measureAnchorLayout(),\r\n    ]);\r\n\r\n    // When visible is true for first render\r\n    // native views can be still not rendered and\r\n    // measureMenuLayout/measureAnchorLayout functions\r\n    // return wrong values e.g { x:0, y: 0, width: 0, height: 0 }\r\n    // so we have to wait until views are ready\r\n    // and rerun this function to show menu\r\n    if (\r\n      !windowLayout.width ||\r\n      !windowLayout.height ||\r\n      !menuLayout.width ||\r\n      !menuLayout.height ||\r\n      (!anchorLayout.width && !this.isAnchorCoord()) ||\r\n      (!anchorLayout.height && !this.isAnchorCoord())\r\n    ) {\r\n      // $FlowFixMe\r\n      requestAnimationFrame(this.show);\r\n      return;\r\n    }\r\n\r\n    this.setState(\r\n      () => ({\r\n        left: anchorLayout.x,\r\n        top: anchorLayout.y,\r\n        anchorLayout: {\r\n          height: anchorLayout.height,\r\n          width: anchorLayout.width,\r\n        },\r\n        menuLayout: {\r\n          width: menuLayout.width,\r\n          height: menuLayout.height,\r\n        },\r\n      }),\r\n      () => {\r\n        this.attachListeners();\r\n\r\n        const { animation } = {\r\n          animation: {\r\n            scale: 1.0,\r\n          },\r\n        };\r\n        Animated.parallel([\r\n          Animated.timing(this.state.scaleAnimation, {\r\n            toValue: { x: menuLayout.width, y: menuLayout.height },\r\n            duration: ANIMATION_DURATION * animation.scale,\r\n            easing: EASING,\r\n            useNativeDriver: true,\r\n          }),\r\n          Animated.timing(this.state.opacityAnimation, {\r\n            toValue: 1,\r\n            duration: ANIMATION_DURATION * animation.scale,\r\n            easing: EASING,\r\n            useNativeDriver: true,\r\n          }),\r\n        ]).start(({ finished }) => {\r\n          if (finished) {\r\n            this.focusFirstDOMNode(this.menu);\r\n          }\r\n        });\r\n      }\r\n    );\r\n  };\r\n\r\n  hide = () => {\r\n    this.removeListeners();\r\n\r\n    const { animation } = {\r\n      animation: {\r\n        scale: 1.0,\r\n      },\r\n    };\r\n    Animated.timing(this.state.opacityAnimation, {\r\n      toValue: 0,\r\n      duration: ANIMATION_DURATION * animation.scale,\r\n      easing: EASING,\r\n      useNativeDriver: true,\r\n    }).start(({ finished }) => {\r\n      if (finished) {\r\n        this.setState({ menuLayout: { width: 0, height: 0 }, rendered: false });\r\n        this.state.scaleAnimation.setValue({ x: 0, y: 0 });\r\n        this.focusFirstDOMNode(this.anchor);\r\n      }\r\n    });\r\n  };\r\n\r\n  render() {\r\n    const {\r\n      visible,\r\n      contentStyle,\r\n      style,\r\n      children,\r\n      statusBarHeight,\r\n      onDismiss,\r\n      overlayAccessibilityLabel,\r\n    } = this.props;\r\n    const { rendered, menuLayout, anchorLayout, opacityAnimation, scaleAnimation } = this.state;\r\n\r\n    let { left, top } = this.state;\r\n\r\n    // I don't know why but on Android measure function is wrong by 24\r\n    const additionalVerticalValue = Platform.select({\r\n      android: statusBarHeight,\r\n      default: 0,\r\n    });\r\n\r\n    const scaleTransforms = [\r\n      {\r\n        scaleX: scaleAnimation.x.interpolate({\r\n          inputRange: [0, menuLayout.width],\r\n          // $FlowFixMe\r\n          outputRange: [0, 1],\r\n        }),\r\n      },\r\n      {\r\n        scaleY: scaleAnimation.y.interpolate({\r\n          inputRange: [0, menuLayout.height],\r\n          // $FlowFixMe\r\n          outputRange: [0, 1],\r\n        }),\r\n      },\r\n    ];\r\n\r\n    const windowLayout = Dimensions.get('window');\r\n\r\n    // We need to translate menu while animating scale to imitate transform origin for scale animation\r\n    const positionTransforms = [];\r\n\r\n    // Check if menu fits horizontally and if not align it to right.\r\n    if (left <= windowLayout.width - menuLayout.width - SCREEN_INDENT) {\r\n      positionTransforms.push({\r\n        translateX: scaleAnimation.x.interpolate({\r\n          inputRange: [0, menuLayout.width],\r\n          // $FlowFixMe\r\n          outputRange: [-(menuLayout.width / 2), 0],\r\n        }),\r\n      });\r\n\r\n      // Check if menu position has enough space from left side\r\n      if (left < SCREEN_INDENT) {\r\n        left = SCREEN_INDENT;\r\n      }\r\n    } else {\r\n      positionTransforms.push({\r\n        translateX: scaleAnimation.x.interpolate({\r\n          inputRange: [0, menuLayout.width],\r\n          // $FlowFixMe\r\n          outputRange: [menuLayout.width / 2, 0],\r\n        }),\r\n      });\r\n\r\n      left += anchorLayout.width - menuLayout.width;\r\n\r\n      const right = left + menuLayout.width;\r\n      // Check if menu position has enough space from right side\r\n      if (right > windowLayout.width - SCREEN_INDENT) {\r\n        left = windowLayout.width - SCREEN_INDENT - menuLayout.width;\r\n      }\r\n    }\r\n\r\n    // If the menu is larger than available vertical space,\r\n    // calculate the height of scrollable view\r\n    let scrollableMenuHeight = 0;\r\n\r\n    // Check if the menu should be scrollable\r\n    if (\r\n      // Check if the menu overflows from bottom side\r\n      top >= windowLayout.height - menuLayout.height - SCREEN_INDENT - additionalVerticalValue &&\r\n      // And bottom side of the screen has more space than top side\r\n      top <= windowLayout.height - top\r\n    ) {\r\n      // Scrollable menu should be below the anchor (expands downwards)\r\n      scrollableMenuHeight = windowLayout.height - top - SCREEN_INDENT - additionalVerticalValue;\r\n    } else if (\r\n      // Check if the menu overflows from bottom side\r\n      top >= windowLayout.height - menuLayout.height - SCREEN_INDENT - additionalVerticalValue &&\r\n      // And top side of the screen has more space than bottom side\r\n      top >= windowLayout.height - top &&\r\n      // And menu overflows from top side\r\n      top <= menuLayout.height - anchorLayout.height + SCREEN_INDENT - additionalVerticalValue\r\n    ) {\r\n      // Scrollable menu should be above the anchor (expands upwards)\r\n      scrollableMenuHeight = top + anchorLayout.height - SCREEN_INDENT + additionalVerticalValue;\r\n    }\r\n\r\n    // Scrollable menu max height\r\n    scrollableMenuHeight =\r\n      scrollableMenuHeight > windowLayout.height - 2 * SCREEN_INDENT\r\n        ? windowLayout.height - 2 * SCREEN_INDENT\r\n        : scrollableMenuHeight;\r\n\r\n    // Menu is typically positioned below the element that generates it\r\n    // So first check if it fits below the anchor (expands downwards)\r\n    if (\r\n      // Check if menu fits vertically\r\n      top <= windowLayout.height - menuLayout.height - SCREEN_INDENT - additionalVerticalValue ||\r\n      // Or if the menu overflows from bottom side\r\n      (top >= windowLayout.height - menuLayout.height - SCREEN_INDENT - additionalVerticalValue &&\r\n        // And bottom side of the screen has more space than top side\r\n        top <= windowLayout.height - top)\r\n    ) {\r\n      positionTransforms.push({\r\n        translateY: scaleAnimation.y.interpolate({\r\n          inputRange: [0, menuLayout.height],\r\n          // $FlowFixMe\r\n          outputRange: [-((scrollableMenuHeight || menuLayout.height) / 2), 0],\r\n        }),\r\n      });\r\n\r\n      // Check if menu position has enough space from top side\r\n      if (top < SCREEN_INDENT) {\r\n        top = SCREEN_INDENT;\r\n      }\r\n    } else {\r\n      positionTransforms.push({\r\n        translateY: scaleAnimation.y.interpolate({\r\n          inputRange: [0, menuLayout.height],\r\n          // $FlowFixMe\r\n          outputRange: [(scrollableMenuHeight || menuLayout.height) / 2, 0],\r\n        }),\r\n      });\r\n\r\n      top += anchorLayout.height - (scrollableMenuHeight || menuLayout.height);\r\n\r\n      const bottom = top + (scrollableMenuHeight || menuLayout.height) + additionalVerticalValue;\r\n\r\n      // Check if menu position has enough space from bottom side\r\n      if (bottom > windowLayout.height - SCREEN_INDENT) {\r\n        top =\r\n          scrollableMenuHeight === windowLayout.height - 2 * SCREEN_INDENT\r\n            ? -SCREEN_INDENT * 2\r\n            : windowLayout.height - menuLayout.height - SCREEN_INDENT - additionalVerticalValue;\r\n      }\r\n    }\r\n\r\n    const shadowMenuContainerStyle = {\r\n      opacity: opacityAnimation,\r\n      transform: scaleTransforms,\r\n      borderRadius: 5,\r\n      ...(scrollableMenuHeight ? { height: scrollableMenuHeight } : {}),\r\n    };\r\n\r\n    const positionStyle = {\r\n      top: this.isAnchorCoord() ? top : top + additionalVerticalValue,\r\n      ...(I18nManager.isRTL ? { right: left } : { left }),\r\n    };\r\n    return rendered ? (\r\n      <View style={StyleSheet.absoluteFill} collapsable={false}>\r\n        <TouchableWithoutFeedback\r\n          accessibilityLabel={overlayAccessibilityLabel}\r\n          accessibilityRole=\"button\"\r\n          onPress={onDismiss}\r\n        >\r\n          <View style={StyleSheet.absoluteFill} />\r\n        </TouchableWithoutFeedback>\r\n        <View\r\n          ref={(ref) => {\r\n            this.menu = ref;\r\n          }}\r\n          collapsable={false}\r\n          accessibilityViewIsModal={visible}\r\n          style={[styles.wrapper, positionStyle, style]}\r\n          pointerEvents={visible ? 'box-none' : 'none'}\r\n          onAccessibilityEscape={onDismiss}\r\n        >\r\n          <Animated.View style={{ transform: positionTransforms }}>\r\n            <Animated.View\r\n              style={[\r\n                styles.shadowMenuContainer,\r\n                styles.surface,\r\n                shadowMenuContainerStyle,\r\n                contentStyle,\r\n              ]}\r\n            >\r\n              {(scrollableMenuHeight && <ScrollView>{children}</ScrollView>) || (\r\n                <React.Fragment>{children}</React.Fragment>\r\n              )}\r\n            </Animated.View>\r\n          </Animated.View>\r\n        </View>\r\n      </View>\r\n    ) : null;\r\n  }\r\n}\r\n\r\nconst styles = StyleSheet.create({\r\n  wrapper: {\r\n    position: 'absolute',\r\n  },\r\n  shadowMenuContainer: {\r\n    opacity: 0,\r\n    paddingVertical: 8,\r\n    ...Platform.select({\r\n      android: {\r\n        elevation: 8,\r\n      },\r\n      default: {\r\n        shadowColor: 'black',\r\n        shadowOffset: {\r\n          width: 0,\r\n          height: 7,\r\n        },\r\n        shadowOpacity: 0.24,\r\n        shadowRadius: 8,\r\n      },\r\n    }),\r\n  },\r\n  surface: {\r\n    backgroundColor: 'white',\r\n  },\r\n});\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}